// =================================================// ================ @Game Framework// This class creates screens for each state of a game (title, instructions, etc) with an id that corresponds to its state in the game system// This class controls and handles each state of a game with a function for each system state// This class controls the global game sound manager//// To start the game running (assuming GameMain is a subclass of GameFramework):// 	1. add framework to stage : _gameMain = new GameMain(this.stage); addChild(_gameMain);// 	2. set frame rate: GameMain(_gameMain).frameRate = 31; //independent from movie frame rate// 	3. start game timer: GameMain(_gameMain).startTimer(); // =================================================package com.g2.gaming.framework{	import com.g2.gaming.framework.events.ButtonIdEvent;	import com.g2.gaming.framework.events.LevelScreenUpdateEvent;	import com.g2.gaming.framework.events.ScoreBoardUpdateEvent;	import com.g2.gaming.framework.events.SoundEvent;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.text.TextFormat;	import flash.utils.Timer;		// =================================================	// ================ @Class	// =================================================	public class GameFramework extends MovieClip //CONTROLLER CLASS	{	  	public static const EVENT_WAIT_COMPLETE:String = "wait complete"; //if system was suspended, wait time is now complete and next system can be called       	public var systemFunction:Function; //a function called on a system state change      	public var currentSystemState:int;  //the current system state      	public var nextSystemState:int;  //the next system state that should occur after the current state      	public var lastSystemState:int; //reference to the current system state before setting the new system state 				//simple bitmap background elements - not required      	public var appBackBitmapData:BitmapData;        	public var appBackBitmap:Bitmap;       	public var frameRate:int; //independent game frame rate      	public var timerPeriod:Number; //used to calculate fps of game      	public var gameTimer:Timer; //game's "runGame" function executes every tick of this timer      	public var paused:Boolean; //whether game is paused 			//screens for each system state      	public var titleScreen:BasicScreen;        	public var gameOverScreen:BasicScreen;        	public var instructionsScreen:BasicScreen;      	public var levelInScreen:BasicScreen;       	public var pauseScreen:BasicScreen; 		//       	public var scoreBoard:ScoreBoard; //the scoreboard				//text formatting - not required		public var screenTextFormat:TextFormat; 		public var screenButtonFormat:TextFormat; 		public var levelInText:String; //display text on level in screen		public var scoreBoardTextFormat:TextFormat;      	      	public var soundManager:SoundManager; //handles global sound events      	//Game is the custom class to hold all logic for the game       	public var game:Game;        	//waitTime is used in conjunction with the        	//STATE_SYSTEM_WAIT state       	// it suspends the game and allows animation or other        	//processing to finish       	public var waitTime:int=30;       	public var waitCount:int=0;      			// =================================================		// ================ @Constructor		// =================================================		public function GameFramework()		{			super();		}				// =================================================		// ================ @Callable		// =================================================				//FUNCTION : INITIALIZE - override and add all screens here		public function init():void {					}				//FUNCTION : SET A BITMAP BACKGROUND IF NEEDED		public function setApplicationBackGround(width:Number, height:Number, isTransparent:Boolean=false, color:uint = 0x000000):void {			appBackBitmapData = new BitmapData(width, height, isTransparent,color);			appBackBitmap = new Bitmap(appBackBitmapData);			addChild(appBackBitmap);		}				//FUNCTION : START THE GAME TIMER - BASED ON CUSTOM FRAME RATE - GAME PLAY RUNS ACCORDING TO THIS		public function startTimer():void {			timerPeriod = 1000/frameRate;			gameTimer = new Timer(timerPeriod);			gameTimer.addEventListener(TimerEvent.TIMER, runGame);			gameTimer.start();		}				//FUNCTION : RUN GAME - CALLS THE CURRENT SYSTEM STATE OF THE GAME		//called on every tick of gameTimer after startTimer() is called outside framework		//"systemFunction" is set in the switchSystemState function when a state change is requested by another state or by some game event		public function runGame(e:TimerEvent):void {			if (systemFunction is Function) {				systemFunction();			}			e.updateAfterEvent();		}				//FUNCTION : SWITCH SYSTEM STATES - HANDLES SYSTEM SWITCHES SO THEY NEVER OVERLAP		//switchSystem state is called only when the state is to be changed		public function switchSystemState(stateval:int):void {			trace("switchSystemState:",stateval);			lastSystemState = currentSystemState;			currentSystemState = stateval;			switch(stateval) {				case FrameWorkStates.STATE_SYSTEM_WAIT:					systemFunction = systemWait;				break;									case FrameWorkStates.STATE_SYSTEM_WAIT_FOR_CLOSE:					systemFunction = systemWaitForClose;				break;								case FrameWorkStates.STATE_SYSTEM_TITLE:               	 	systemFunction = systemTitle;                	break;              	case FrameWorkStates.STATE_SYSTEM_INSTRUCTIONS:                		systemFunction = systemInstructions;                	break;              	case FrameWorkStates.STATE_SYSTEM_NEW_GAME:                		systemFunction = systemNewGame;               	break;              	case FrameWorkStates.STATE_SYSTEM_NEW_LEVEL:                		systemFunction = systemNewLevel;                	break;             		case FrameWorkStates.STATE_SYSTEM_LEVEL_IN:                		systemFunction = systemLevelIn;                	break;              	case FrameWorkStates.STATE_SYSTEM_GAME_PLAY:                		systemFunction = systemGamePlay;                	break                	               	case FrameWorkStates.STATE_SYSTEM_PAUSE:                		systemFunction = systemPause;                	break;             	case FrameWorkStates.STATE_SYSTEM_GAME_OVER:                		systemFunction = systemGameOver;                	break;			}		}				//FUNCTION : TITLE SCREEN SYSTEM STATE		public function systemTitle():void {			addChild(titleScreen);			titleScreen.addEventListener(ButtonIdEvent.BUTTON_ID, okButtonClickListener, false, 0, true);			switchSystemState(FrameWorkStates.STATE_SYSTEM_WAIT_FOR_CLOSE); 			nextSystemState = FrameWorkStates.STATE_SYSTEM_INSTRUCTIONS;		}				//FUNCTION : INSTRUCTIONS SCREEN SYSTEM STATE		public function systemInstructions():void {           	addChild(instructionsScreen);              	instructionsScreen.addEventListener(ButtonIdEvent.BUTTON_ID,okButtonClickListener, false, 0, true);          	switchSystemState(FrameWorkStates.STATE_SYSTEM_WAIT_FOR_CLOSE);          	nextSystemState = FrameWorkStates.STATE_SYSTEM_NEW_GAME;       	}      			//FUNCTION : PAUSE SCREEN SYSTEM STATE      	public function systemPause():void {       		paused = true;          	addChild(pauseScreen);              	pauseScreen.addEventListener(ButtonIdEvent.BUTTON_ID,okButtonClickListener, false, 0, true);          	switchSystemState(FrameWorkStates.STATE_SYSTEM_WAIT_FOR_CLOSE);          	nextSystemState = FrameWorkStates.STATE_SYSTEM_GAME_PLAY;       	}        			//FUNCTION : NEW GAME SYSTEM STATE      	public function systemNewGame():void {           	addChild(game);              	game.addEventListener(ScoreBoardUpdateEvent.UPDATE_TEXT,scoreBoardUpdateListener, false, 0, true);          	game.addEventListener(LevelScreenUpdateEvent.UPDATE_TEXT, levelScreenUpdateListener, false, 0, true);         	game.addEventListener(SoundEvent.PLAY_SOUND, soundEventListener,false, 0, true);         	game.addEventListener(SoundEvent.STOP_SOUND, soundEventListener,false, 0, true);         	game.addEventListener(Game.GAME_OVER, gameOverListener, false, 0, true);         	game.addEventListener(Game.NEW_LEVEL, newLevelListener, false, 0, true);         	game.addEventListener(Game.PAUSE, pauseListener, false, 0, true);         	game.newGame();         	switchSystemState(FrameWorkStates.STATE_SYSTEM_NEW_LEVEL);       	}       			//FUNCTION : NEW LEVEL SYSTEM STATE      	public function systemNewLevel():void {      		game.newLevel();      		switchSystemState(FrameWorkStates.STATE_SYSTEM_LEVEL_IN);      	}      			//FUNCTION : LEVEL IN SYSTEM STATE      	public function systemLevelIn():void {      		addChild(levelInScreen);      		waitTime = 30;      		switchSystemState(FrameWorkStates.STATE_SYSTEM_WAIT);      		nextSystemState = FrameWorkStates.STATE_SYSTEM_GAME_PLAY;      		addEventListener(EVENT_WAIT_COMPLETE, waitCompleteListener, false, 0, true);      	}      			//FUNCTION : GAME OVER SYSTEM STATE      	public function systemGameOver():void {      		removeChild(game);      		addChild(gameOverScreen);      		gameOverScreen.addEventListener(ButtonIdEvent.BUTTON_ID, okButtonClickListener, false, 0, true);      		switchSystemState(FrameWorkStates.STATE_SYSTEM_WAIT_FOR_CLOSE);      		nextSystemState = FrameWorkStates.STATE_SYSTEM_TITLE;      	}      			//FUNCTION : GAME PLAY SYSTEM STATE      	public function systemGamePlay():void {      		game.runGame();      	}      			//FUNCTION : WAIT FOR CLOSE SYSTEM STATE (occurs when system is waiting for an ok button listener to switch the game state)      	public function systemWaitForClose():void {      		//do nothing      	}      			//FUNCTION : WAIT SYSTEM STATE (used to set a numeric time (waitTime) between states rather than wait for a button event)      	public function systemWait():void {      		waitCount++;      		if(waitCount > waitTime) {      			waitCount = 0;      			dispatchEvent(new Event(EVENT_WAIT_COMPLETE));      		}      	}				// =================================================		// ================ @Handlers		// =================================================      			//FUNCTION : CLICK BUTTON TO ADVANCE TO ANOTHER STATE OF GAME		//when button is clicked on a Basic Screen class (e.g. "play") , the screen's id is dispatched to the Game Framework and handled accordingly      	public function okButtonClickListener(e:ButtonIdEvent):void {      		switch(e.id) {      			case FrameWorkStates.STATE_SYSTEM_TITLE:                		removeChild(titleScreen);                		titleScreen.removeEventListener(ButtonIdEvent.BUTTON_ID,okButtonClickListener);                	break;              	case FrameWorkStates.STATE_SYSTEM_INSTRUCTIONS:                		removeChild(instructionsScreen);                 	instructionsScreen.removeEventListener(ButtonIdEvent.BUTTON_ID,okButtonClickListener);                	break;              	case FrameWorkStates.STATE_SYSTEM_GAME_OVER:               		removeChild(gameOverScreen);                 	gameOverScreen.removeEventListener(ButtonIdEvent.BUTTON_ID, okButtonClickListener);                               	break;                	               	case FrameWorkStates.STATE_SYSTEM_PAUSE:                		paused = false;               		removeChild(gameOverScreen);                 	gameOverScreen.removeEventListener(ButtonIdEvent.BUTTON_ID,okButtonClickListener);                	game.resumeGame();                               	break;       		}      		switchSystemState(nextSystemState);      	}      			//FUNCTION : UPDATE SCOREBOARD      	public function scoreBoardUpdateListener(e:ScoreBoardUpdateEvent):void {      		scoreBoard.update(e.element, e.value);      	}      			//FUNCTION : UPDATE LEVEL SCREEN INFORMATION      	public function levelScreenUpdateListener(e:LevelScreenUpdateEvent):void {      		levelInScreen.setDisplayText(levelInText + e.text);      	}				//FUNCTION : HANDLE GAME OVER		public function gameOverListener(e:Event):void { //listens for Game.GAMEOVER         	switchSystemState(FrameWorkStates.STATE_SYSTEM_GAME_OVER);         	game.removeEventListener(ScoreBoardUpdateEvent.UPDATE_TEXT,scoreBoardUpdateListener);          	game.removeEventListener(LevelScreenUpdateEvent.UPDATE_TEXT, levelScreenUpdateListener);         	game.removeEventListener(SoundEvent.PLAY_SOUND, soundEventListener);          	game.removeEventListener(SoundEvent.STOP_SOUND, soundEventListener);          	game.removeEventListener(Game.GAME_OVER, gameOverListener);          	game.removeEventListener(Game.NEW_LEVEL, newLevelListener);          	game.removeEventListener(Game.PAUSE, pauseListener);      	}      			//FUNCTION : HANDLE NEW LEVEL     	public function newLevelListener(e:Event):void { //listens for Game.NEWLEVEL     		switchSystemState(FrameWorkStates.STATE_SYSTEM_NEW_LEVEL);     	}     			//FUNCTION : HANDLE PAUSE     	public function pauseListener(e:Event):void {      		switchSystemState(FrameWorkStates.STATE_SYSTEM_PAUSE);     	}     			//FUNCTION : HANDLE WAIT TIME BETWEEN SYSTEM STATES IF NEEDED     	public function waitCompleteListener(e:Event):void {     		switch(lastSystemState){     			case FrameWorkStates.STATE_SYSTEM_LEVEL_IN:     				if (levelInScreen != null) {     					removeChild(levelInScreen);     				}     			break;     		}     		removeEventListener(EVENT_WAIT_COMPLETE, waitCompleteListener);     		switchSystemState(nextSystemState);     	}				//FUNCTION : HANDLE SOUND EVENT 		public function soundEventListener(e:SoundEvent):void {    			if (e.type == SoundEvent.PLAY_SOUND) {   				soundManager.playSound(e.name, e.isSoundTrack, e.loops, e.offset, e.volume );    			}else {   				soundManager.stopSound(e.name, e.isSoundTrack);    			} 		}		}}