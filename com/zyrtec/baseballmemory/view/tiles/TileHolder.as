package com.zyrtec.baseballmemory.view.tiles{	import com.bigspaceship.events.AnimationEvent;	import com.greensock.TweenMax;	import com.greensock.easing.*;	import com.greensock.plugins.*;	import com.zyrtec.baseballmemory.events.BaseballMemoryEvent;	import com.zyrtec.baseballmemory.model.BMModel;		import flash.display.*;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.utils.getDefinitionByName;	// =================================================	// ================ @Class	// =================================================	public class TileHolder extends Sprite	{		private var _tileArray:Array;		private var _numRows:uint;		private var _numCols:uint;		private var _totalTiles:uint;		private var _selectedTileArray:Array; //to prevent selected tiles from showing up in bonus matches		private var	_model:BMModel;		// Game Model (Singleton)				// =================================================		// ================ @Constructor		// =================================================		public function TileHolder(numRows:uint, numCols:uint, totalTiles:uint){						_model = BMModel.getInstance();						_numRows = numRows;			_numCols = numCols;			_totalTiles = totalTiles;						TweenPlugin.activate([VisiblePlugin, TransformAroundPointPlugin, TransformAroundCenterPlugin, ShortRotationPlugin, GlowFilterPlugin, BezierPlugin]);		}				// =================================================		// ================ @Callable		// =================================================				//FUNCTION : ADD EVENTS		public function addEvents():void {			var i:uint;			for (i=0; i<_totalTiles; i++){				Tile(_tileArray[i]).addEventListener(BaseballMemoryEvent.TILE_CLICK, onTileClicked);				Tile(_tileArray[i]).addEvents();			}		}				//FUNCTION : REMOVE EVENTS		public function removeEvents():void { 			var i:uint;			for (i=0; i<_tileArray.length; i++){ 				Tile(_tileArray[i]).removeEventListener(BaseballMemoryEvent.TILE_CLICK, onTileClicked);				Tile(_tileArray[i]).removeEvents();			}		}				//FUNCTION : ANIMATE IN		public function animateIn():void		{			var tileOrder:Array=new Array();			var tileArrayLength:uint = _tileArray.length;			for ( var j=0; j<tileArrayLength; j++ ) {				tileOrder.push(j)			};			shuffle(tileOrder);			var completeFunction:Function=null;			var i:uint;			for (i=0; i<_totalTiles; i++){				_tileArray[tileOrder[i]].visible = true;				if (i == _totalTiles-1) { //on last animating tile					//completeFunction = onRevealComplete;					TweenMax.delayedCall(4.5, onRevealComplete);				}				TweenMax.to(_tileArray[tileOrder[i]], 0.25, {transformAroundCenter:{scaleX:1}, ease:Back.easeOut, delay:i*0.05});			}		}		//FUNCTION : CREATE TILES		public function createTiles():void {			if (_tileArray==null) {				_tileArray = new Array();			}						if (_selectedTileArray==null) {				_selectedTileArray = new Array();			} else {				_selectedTileArray.splice(0);			}					//	var backRef:MovieClip = new BackTileRefMC(); //holds instances of the tiles so no reference error occurs when getting definition by name					//	backRef.visible = false;			var i:uint;			var tile:Tile;			var ClassRef:Class;			var bmd:BitmapData;						var randBackTileOrder:Array=new Array();			for (i=0; i<_totalTiles; i++ ) {				randBackTileOrder[i] = i+1;			};						shuffle(randBackTileOrder);						for (i=0; i<_totalTiles; i++){				tile = new Tile();				tile.id = randBackTileOrder[i];//i+1;				if ((randBackTileOrder[i])>(_totalTiles/2)) { 					// after half the tiles, back image starts to repeat from beginning					ClassRef = getDefinitionByName("BackTile"+((randBackTileOrder[i])-(_totalTiles/2)).toString()) as Class;				} else {					ClassRef = getDefinitionByName("BackTile"+(randBackTileOrder[i]).toString()) as Class;				}				// bmd = BitmapData(new ClassRef());				// tile.side2 = new Bitmap(bmd);				tile.side2 = MovieClip(new ClassRef()); //using 1 movieclip instead of exported pngs				_tileArray[i] = tile;			}						// jumble tile array			var mixedArray:Array = _tileArray.slice()			var randNum:int			var obj:Object;			for (i = 0; i<length; i++) {				obj = mixedArray[i];				randNum = Math.floor(Math.random()*length);				mixedArray[i] = mixedArray[randNum];				mixedArray[randNum] = obj;							}			_tileArray = mixedArray;			//pass front image to tile in order			var frontRef:MovieClip = new FrontTileRefMC(); //holds instances of the tiles so no reference error occurs when getting definition by name			frontRef.visible = false;			for (i=0; i<_totalTiles; i++){				ClassRef = getDefinitionByName("Tile"+(i+1).toString()) as Class;				bmd = BitmapData(new ClassRef());				Tile(_tileArray[i]).side1 = new Bitmap(bmd,"auto", true);			/////////////////////////////////////////////////////////////////////////////////////////////////// DEBUG							if (_model.isDebugMode) {					var myFormat:TextFormat = new TextFormat();						myFormat.size = 16;						myFormat.color = 0xFFFFFF;						var tf:TextField=new TextField();							tf.selectable=false;							tf.multiline=false;							tf.border=false;							tf.embedFonts=false;							tf.autoSize='left';							tf.defaultTextFormat = myFormat;						Tile(_tileArray[i]).addChild(tf);							if (mixedArray[i].id <= (_totalTiles/2)) {							tf.text=mixedArray[i].id						} else {							tf.text= String(mixedArray[i].id - _totalTiles/2);						}								}			///////////////////////////////////////////////////////////////////////////////////////////////////				_tileArray[i].visible = false;				addChild(_tileArray[i]);				_tileArray[i].scaleX=0;			}						//lay em out in order			var tileOrder:Array=new Array();			var tileObj:Object;			var spacing:int = 84;			var tileWidth:int = 66;			var tileHeight:int = 75;			var tileNum:uint;			for (var rowNum:uint=0; rowNum<_numRows; rowNum++) {				for (var colNum:uint=0; colNum<_numCols; colNum++) {					tileNum = (_numCols*rowNum)+colNum;					_tileArray[tileNum].startX = (tileWidth*colNum)+spacing;					_tileArray[tileNum].startY =  (tileHeight*rowNum)+spacing;					_tileArray[tileNum].orderNum = tileNum;					tileObj = new Object();					tileObj.x = _tileArray[tileNum].startX;					tileObj.y = _tileArray[tileNum].startY;					tileOrder.push(tileObj);				}			}						shuffle(tileOrder); //shuffle up the x and y array and set the tiles to those random positions						for (i = 0; i<_totalTiles; i++) {				_tileArray[i].x = tileOrder[i].x;				_tileArray[i].y = tileOrder[i].y;			}		}				//FUNCTION : FLIP BONUS MATCHED TILES		public function flipBonusMatch():void {			if (_selectedTileArray.length==0) {				_selectedTileArray.push(13);				_selectedTileArray.push(37);//exclude ipad			}			trace("selected tiles = "+_selectedTileArray);			//loop through tile array and make an array of all the unselected tiles			var i:uint;			var unselectedTileArray:Array = new Array();			for (i=0; i<_totalTiles; i++){ 				unselectedTileArray.push(i+1);			}						for (i=0; i<unselectedTileArray.length; i++){  //for every id in this array, check if it matches something in the selected array				for (var j:uint =0; j<_selectedTileArray.length; j++) {					if (unselectedTileArray[i] == _selectedTileArray[j]) {						unselectedTileArray.splice(i, 1);					}				}			}						trace(")}}}}}} array of unselected or forbidden tiles that can be picked from = "+unselectedTileArray); 						//pick a random tile from that array			var randTileNum:uint = Math.floor(Math.random()*(unselectedTileArray.length-1)); 			var randTileId:uint=unselectedTileArray[randTileNum];			var matchTileId:uint;//matching tile's id						//find the match			if (randTileId <= (_totalTiles/2)) { //first half of tiles				matchTileId = randTileId+(_totalTiles/2);//e.g. in 10 tiles, 1 and 6 are a match, 2 and 7, and so on				} else { //second half of tiles				matchTileId = randTileId-(_totalTiles/2);			}			trace("the match ids = ", randTileId, matchTileId);					//find and grab the rand and matching tiles			var numDone:uint = 0;			for (i=0; i<_totalTiles; i++){  //array is shuffled so look for correct tile				if (Tile(_tileArray[i]).id == matchTileId || Tile(_tileArray[i]).id==randTileId) { 					Tile(_tileArray[i]).selected = true;					Tile(_tileArray[i]).removeEvents();					this.setChildIndex(Tile(_tileArray[i]), this.numChildren-1);					Tile(_tileArray[i]).flip();					_selectedTileArray.push(Tile(_tileArray[i]).id);					//TweenMax.to(Tile(_tileArray[i]), 0.3, {glowFilter:{color:0xF22500, alpha:0.75, blurX:20, blurY:20}, repeat:20, yoyo:true});					TweenMax.delayedCall(1, Tile(_tileArray[i]).discard);					numDone++;					if (numDone==2) {						Tile(_tileArray[i]).addEventListener(BaseballMemoryEvent.TILE_DISCARDED, onBonusPairFlipped);						break;					}				}			}						//listen for one to be completely discarded - then tell game it's done			//Tile(_tileArray[randTileNum]).addEventListener(BaseballMemoryEvent.TILE_DISCARDED, onBonusPairFlipped);						//TweenMax.to(Tile(_tileArray[randTileNum]), 0.3, {glowFilter:{color:0xF22500, alpha:0.75, blurX:20, blurY:20}, repeat:20, yoyo:true});			//wait a few seconds and fly the tile off screen		}		//FUNCTION : CLEAR THE BOARD on game over		public function clearTheBoard()		{			trace("clear the tile board");			for (var i:int=_tileArray.length-1; i>=0; i--){				_tileArray[i].visible = false;				Tile(_tileArray[i]).removeEventListener(BaseballMemoryEvent.TILE_CLICK, onTileClicked);				Tile(_tileArray[i]).removeEvents();				this.removeChildAt(i);				_tileArray[i] = null;			}				_tileArray.splice(0);		}				private static function shuffle(a:Array):void 		{			var l:int=a.length;			var i:int=0;			var rand:int;			for(;i<l;i++)			{				var tmp:* =a[int(i)];				rand=int(Math.random()*l);				a[int(i)]=a[rand];				a[int(rand)]=tmp;			}		}		// =================================================		// ================ @Handlers		// =================================================				//FUNCTION : ON REVEAL COMPLETE		private function onRevealComplete(e:AnimationEvent=null) { //flip em to the front			var i:uint;			for (i=0; i<_totalTiles; i++){				if (i == _totalTiles-1) { //on last animating tile					TweenMax.delayedCall(1.2, onFlipsComplete);				}				_tileArray[i].introFlip();			}		}				//FUNCTION : ON FLIPS COMPLETE - done flipping to the front, rearrange the pieces to correct order		private function onFlipsComplete(e:AnimationEvent=null) { 			var completeFunction:Function=null;			var startFunction:Function;			var i:uint;			for (i=0; i<_totalTiles; i++){				if (i == _totalTiles-1) { //on last animating tile					completeFunction = onAnimatedInComplete;				}				//var randSlopeX:Number = Math.random()*_tileArray[i].x;				//var randSlopeY:Number = Math.random()*_tileArray[i].y;				//bezier:[{x:randSlopeX, y:randSlopeY}, {x:_tileArray[i].startX, y:_tileArray[i].startY}]				//startFunction = function setDepth():void { trace(_tileArray[i]);};//this.setChildIndex(_tileArray[i], this.numChildren-1);};				this.setChildIndex(_tileArray[i], this.numChildren-1);				TweenMax.to(_tileArray[i], 0.4, {x:_tileArray[i].startX, y:_tileArray[i].startY, ease:Cubic.easeOut, delay:i*0.04, onComplete:completeFunction});			}		}				//FUNCTION : ON ANIMATED IN COMPLETE		private function onAnimatedInComplete(e:AnimationEvent=null) { 			TweenMax.delayedCall(0.5, this.dispatchEvent, [new AnimationEvent(AnimationEvent.COMPLETE)]);			//this.dispatchEvent(new AnimationEvent(AnimationEvent.COMPLETE));		}				//FUNCTION : ON TILE CLICKED		private function onTileClicked(e:BaseballMemoryEvent):void {			dispatchEvent(new BaseballMemoryEvent(BaseballMemoryEvent.TILE_CLICK, e.currentTarget));		}		//FUNCTION : ON BONUS PAIR FLIPPED 		private function onBonusPairFlipped(e:BaseballMemoryEvent):void {			e.target.removeEventListener(BaseballMemoryEvent.TILE_FLIPPED, onBonusPairFlipped);			dispatchEvent(new BaseballMemoryEvent(BaseballMemoryEvent.BONUS_FLIPS_COMPLETE));		}	}}