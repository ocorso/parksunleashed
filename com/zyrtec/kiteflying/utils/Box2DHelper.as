package com.zyrtec.kiteflying.utils{		import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.*;	import Box2D.Dynamics.Joints.*;		public class Helper {		public static function CreateWorld(gravity:Array, doSleep:Boolean = true) : b2World {			return new b2World(new b2Vec2(gravity[0], gravity[1]), doSleep);		}				public static function CreateBodyDef(posX:Number, posY:Number, worldScale:Number = 1, obj:* = false) : b2BodyDef {			var body:b2BodyDef = new b2BodyDef();			//... Defaults [start]			body.type     = b2Body.b2_dynamicBody;			body.position = new b2Vec2(posX / worldScale, posY / worldScale);			//... Defaults [end]						return Helper.AppendObject(body, obj);		}				public static function CreateFixture(shape:*, obj:* = false, density:Number=20, friction:Number=0.9, rest:Number=0.5) : b2FixtureDef {			var fixture:b2FixtureDef = new b2FixtureDef();			//... Defaults [start]			fixture.shape       = shape;			fixture.density     = density;			fixture.friction    = friction;			fixture.restitution = rest;			//... Defaults [end]						return Helper.AppendObject(fixture, obj);		}				public static function CreateWorldBody(world:b2World, bodyDef:b2BodyDef, fixtures:Array) : b2Body {			var body:b2Body = world.CreateBody(bodyDef);			for(var i:String in fixtures) body.CreateFixture(fixtures[i]);						return body;		}				public static function CreateBox(x:Number, y:Number, w:Number) : b2PolygonShape {			var box:b2PolygonShape = new b2PolygonShape();			box.SetAsBox(x / w, y / w);						return box;		}				public static function CreateOrientedBox(x:Number, y:Number, w:Number, c:Array = null, a:Number = 0.0) : b2PolygonShape {			var vert:b2Vec2 = null;			if(c) vert = new b2Vec2(c[0] / w, c[1] / w);						var box:b2PolygonShape = new b2PolygonShape();			box.SetAsOrientedBox(x / w, y / w, vert, a);						return box;		}				public static function CreateTriangle(x1:int, y1:int, x2:int, y2:int, x3:int, y3:int):b2PolygonShape {			var chainDef:b2EdgeChainDef=new b2EdgeChainDef;			chainDef.isALoop=true;			chainDef.vertices.length=0;			var ratio:Number=1;						var chainShape:b2PolygonShape = new b2PolygonShape();						var vertexList:Array=[{x:x1,y:y1}, {x:x2,y:y2}, {x:x3,y:y3}]; //3 vertices produces a triangle			for (var i:int=0; i < vertexList.length; i++) {   				chainDef.vertices.push(new b2Vec2(vertexList[i].x / 30,vertexList[i].y / 30));			}			chainDef.vertexCount=chainDef.vertices.length;						chainShape.SetAsArray(chainDef.vertices, chainDef.vertexCount);						return chainShape;				}				public static function AppendObject(obj:*, appendix:*) : * {			if(!appendix) return obj;						for(var i:String in appendix) obj[i] = appendix[i];			return obj;		}	}}