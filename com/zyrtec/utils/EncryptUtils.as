package com.zyrtec.utils{	import com.adobe.crypto.HMAC;	import com.adobe.serialization.json.JSON;	import com.bigspaceship.utils.Out;	import com.codeazur.utils.StringUtils;	import com.hurlant.crypto.Crypto;	import com.hurlant.crypto.symmetric.ICipher;	import com.hurlant.crypto.symmetric.IPad;	import com.hurlant.crypto.symmetric.IVMode;	import com.hurlant.crypto.symmetric.NullPad;	import com.hurlant.crypto.symmetric.PKCS5;	import com.hurlant.util.Base64;	import com.hurlant.util.Hex;		import flash.display.Bitmap;	import flash.display.Loader;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.net.URLRequest;	import flash.utils.ByteArray;	public class EncryptUtils extends EventDispatcher	{		private var salt:ByteArray;				private static const IV:String = "claus is awesome";		private var _badge:Bitmap;				//need to add game id's here for a unique salt		/*		 * 				game.ids.kite = G0002				game.ids.baseball = G0003				game.ids.tugofwar = G0004				game.ids.matchdogs = G0005				game.ids.findbones = G0006				game.ids.digdogrun = G0007				game.ids.shellgame = G0008				game.ids.merchhunt = G0009				game.ids.piano = G0010				game.ids.lookseat = G0011		*/		// =================================================		// ================ @HAUS MATCH		// =================================================		public function EncryptUtils()		{			Out.status(this, "constructor");			//_generateKeyFromLibrary();		}				/*private function _generateKeyFromLibrary():void{						_badge = new Bitmap(new Badge());			var pixels:Array = [[30,12], [44,34], [5,19], [49,24], [47,15], [54,37], [13,7], [46,31]];			salt = new ByteArray();			for (var i:int = 0; i < pixels.length; i++) {				var pixelCoord:Array = pixels[i] as Array;				var pixel:uint = _badge.bitmapData.getPixel32(pixelCoord[0], pixelCoord[1]);				salt.writeUnsignedInt(pixel);			}					}*/				// =================================================		// ================ @Callable		// =================================================		public function encrypt(dataObjToEncrypt:Object, algorithm:String = "aes256-cbc", padding:String = "None"):String		{			var input:String 	= JSON.encode(dataObjToEncrypt);			var idata:ByteArray = Hex.toArray(Hex.fromString(input));			var pad:IPad = (padding == "pkcs5") ? new PKCS5 : new NullPad;			var cipher:ICipher 	= Crypto.getCipher(algorithm, salt, pad);			pad.setBlockSize(cipher.getBlockSize());			IVMode(cipher).IV 	= Hex.toArray(Hex.fromString(IV));			cipher.encrypt(idata);			idata.position 		= 0;			return Base64.encodeByteArray(idata); 		}				public function decrypt(input:ByteArray, algorithm:String = "aes256-cbc", padding:String = "None"):String		{			var pad:IPad = (padding == "pkcs5") ? new PKCS5 : new NullPad;			var cipher:ICipher = Crypto.getCipher(algorithm, salt, pad);			pad.setBlockSize(cipher.getBlockSize());			IVMode(cipher).IV = Hex.toArray(Hex.fromString(IV));			cipher.decrypt(input);			input.position = 0;			return input.readUTFBytes(input.length);		}		public function get saltForServices():String{			var key:String = "";			salt.position = 0;			for(var j:int = 0; j < salt.length / 4; j++) {				key += StringUtils.printf("%08lx", salt.readInt());			}			return key;					}//end function			public function createSaltFromString(value:String):void {			salt = new ByteArray();			salt.writeUTFBytes(value);			salt.compress();						trace("ENCRYPTION: TRACING SALT TO STRING ::::: "+salt.toString());		}		}//end class}//end package